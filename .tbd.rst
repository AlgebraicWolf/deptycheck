- CI

  - Сборка библиотеки deptycheck
  - Сборка примера спецификации языка PIL
  - Сборка положительных и несборка отрицательных примеров на языке PIL
  - Генерация примеров на языке PIL при помощи библиотеки deptycheck

- Отработка приёмов спецификации

  - Определённость значения переменной

    - Добавление понятия

    - Внесение соответствующих изменений в спецификацию

      - Например, что после if определено только то, что определено после любой из ветвей

    - Добавление свойства, что переменную можно использовать в выражении только когда она определена

  - Конечность и dead-code

    - Введение в описание statement'а понятия конечного statement'а,
      то есть statement'а, после которого последовательная композиция будет dead-code

    - Изменение правил композиции statement'ов с учётом нового параметра

      - Последовательная композиция требует неконечный первым и её конечность совпадает с конечностью второго аргумента
      - if-statement конечный только если обе ветки конечные
      - while конечный, если его тело конечно
      - и т.д.

  - Return

    - Введение понятия текущего возвращаемого типа
    - Добавление нового типа statement'а -- return, -- который при этом является конечным statement'ом
    - Добавление свойства, что тип выражения в return должен соответствовать типу текущего возвращаемого значения

  - Функция

    - Добавление спецификации на функцию определённой сигнатуры
    - Добавление свойства, что у функции телом должен быть statement, имеющий типов возвращаемого значения тип возвращаемого значения функции
    - Добавление свойства, что все переменные, соответствующие параметрам функции, определены для statement'а, являющегося телом функции

  - Jump

    - Определение того, как адресовать прыжок -- надо понять, как именно
    - Добавление statement'а для jump'а
    - Изменение спецификации с тем, чтобы появилась возможность описания соответствующих свойств --- надо понять, как именно
    - Добавление свойства, что jump может осуществляться в пределах функции

  - Try/catch

    - Изменение спецификации, чтобы можно было отражать соответствующие свойства -- надо понять, как именно
    - Добавление типов statement'ов, соответствующим try-блокам и catch-блокам
    - Добавление свойства, что jump может осуществляться только в пределах try-блока и catch-блока

- Превращение рекурсивных ``Gen``'ов в Чёрч-кодированные, комбинирующиеся рекурсивными схемами.
  В частности, этим можно достигать хитрые комбинации, когда на определённой глубине корректных ``Gen``'ов используются специальные,
  генерирующие некорректные значения.

- Автоматизация генерации ``Gen``'ов по спецификации структуры данных с зависимыми типами

- Попытка разделения спецификации того, что есть в языке, от спецификации того, что нужно для пользовательских свойств.

  Например, в тип можно добавлять какое-нибудь пользовательское свойство, например, наличие конструкции ``if``
  (или, например, наличие паттерна для срабатывания оптимизатора).

  Хочется, чтобы эти спецификации можно было бы добавлять рядом с "основной" спецификацией языка, которая не меняется для добавления новых свойств.
  Соответственно, генераторы будут специфичны для комбинации "основной" спецификации языка и набора пользовательских свойств.

- Параметром генератора может быть "тестовый набор, удовлетворяющий заданному критерию".
  Соответственно, по построению, генератор таких структур данных "тестовый набор" будет генерировать целиковые тестовые наборы,
  удовлетворяющие критерию.

- Не нужно ли вместо statement'а последовательной композиции statement'ов иметь
  отдельную сущность "последовательность statement'ов", то есть "линейный блок"?
