module Test.DepTyCheck.Gen.Auto.Entry

import public Data.So

import public Test.DepTyCheck.Gen.Auto.Checked

%default total

------------------------------------------------------------
--- External generation interface and aux stuff for that ---
------------------------------------------------------------

--- Datatypes needed for the external interface ---

public export
data DatatypeArgPointer
       = Named Name
       | PositionalExplicit Nat

Show DatatypeArgPointer where
  show (Named x) = "named argument `\{show x}`"
  show (PositionalExplicit k) = "explicit argument #\{show k}"

public export
FromString DatatypeArgPointer where
  fromString = Named . fromString

namespace DatatypeArgPointer

  public export
  fromInteger : (x : Integer) -> (0 _ : So (x >= 0)) => DatatypeArgPointer
  fromInteger x = PositionalExplicit $ integerToNat x

--- Internal functions and instances ---

Eq Namespace where
  (MkNS xs) == (MkNS ys) = xs == ys

Eq Name where -- I'm not sure that this implementation is correct for my case.
  (UN x)   == (UN y)   = x == y
  (MN x n) == (MN y m) = x == y && n == m
  (NS s n) == (NS p m) = s == p && n == m
  (DN x n) == (DN y m) = x == y && n == m
  (RF x)   == (RF y)   = x == y
  _ == _ = False

findNthExplicit : Nat -> (xs : List NamedArg) -> Maybe $ Fin xs.length
findNthExplicit _     []                              = Nothing
findNthExplicit Z     (MkArg _ ExplicitArg _ _ :: _ ) = Just FZ
findNthExplicit (S k) (MkArg _ ExplicitArg _ _ :: xs) = FS <$> findNthExplicit k xs
findNthExplicit n     (MkArg _ _           _ _ :: xs) = FS <$> findNthExplicit n xs

findArg : {ty : TypeInfo} -> DatatypeArgPointer -> Maybe $ Fin ty.args.length
findArg (Named n)              = find' ((== n) . name) ty.args
findArg (PositionalExplicit k) = findNthExplicit k ty.args

Show ArgExplicitness where
  show ExplicitArg = "explicit"
  show ImplicitArg = "implicit"

resolveGivens : {ty : TypeInfo} -> ArgExplicitness -> List DatatypeArgPointer -> Elab $ Vect ty.args.length $ Maybe ArgExplicitness
resolveGivens _ [] = pure $ replicate ty.args.length Nothing
resolveGivens p (curr::rest) = do
  let Just pos = findArg curr
    | Nothing => fail "Could not find \{show curr} of type \{show ty.name} listed in \{show p} givens"
  existing <- resolveGivens p rest
  let Nothing = Vect.index pos existing
    | _ => fail "\{show curr} is listed in \{show p} givens several times"
  pure $ replaceAt pos (Just p) existing

mergeSignatureDefs : Vect n $ Maybe ArgExplicitness -> Vect n $ Maybe ArgExplicitness -> Either (Fin n) $ Vect n $ Maybe ArgExplicitness
mergeSignatureDefs [] [] = pure []
mergeSignatureDefs (x::xs) (y::ys) = [| mergeSingle x y :: mapFst FS (mergeSignatureDefs xs ys) |] where
  mergeSingle : Maybe ArgExplicitness -> Maybe ArgExplicitness -> Either (Fin n) $ Maybe ArgExplicitness
  mergeSingle Nothing r = pure r
  mergeSingle l Nothing = pure l
  mergeSingle l r = if l == r then pure l else Left FZ

-- TODO to return the functionality of showing the multiple errors all at once.

signatureDef : (impl, expl : List DatatypeArgPointer) -> {ty : TypeInfo} -> Elab $ Vect ty.args.length $ Maybe ArgExplicitness
signatureDef impl expl = do
  impl' <- resolveGivens ImplicitArg impl
  expl' <- resolveGivens ExplicitArg expl
  let Right merged = mergeSignatureDefs impl' expl'
    | Left badPosition => fail "\{humanReadableArgumentFor badPosition} is listed in both implicit and explicit givens"
  pure merged
  where
    explicitArg : NamedArg -> Bool
    explicitArg $ MkArg {piInfo=ExplicitArg, _} = True
    explicitArg _ = False

    humanReadableArgumentFor : (pos : Fin ty.args.length) -> String
    humanReadableArgumentFor pos = show $ case index' ty.args pos of
      MkArg {piInfo=ExplicitArg, name=MN {}, _} => -- machine-generated explicit parameter
        PositionalExplicit $ length $ filter explicitArg $ take (finToNat pos) ty.args
      MkArg {name, _} => Named name

--- Functions for the user ---

||| The entry-point function of automatic generation of `Gen`'s.
|||
||| Consider, you have a `data X (a : A) (b : B n) (c : C) where ...` and
||| you want an autogenerated `Gen` for `X`.
||| Say, you want to have `a` and `c` parameters of `X` to be set by the caller and the `b` parameter to be generated.
||| For this you can call `%runElab generateGensFor "X" [] ["a", "c"]` and
||| you get (besides all) a function with a signature `(a : A) -> (c : C) -> (n ** b : B n ** X a b c)`.
|||
||| You can use positional arguments adderssing instead of named (espesially for unnamed arguments),
||| including mix of positional and named ones.
||| Arguments count from zero and only explicit arguments count.
||| I.e., the following call is equivalent to the one above: `%runElab generateGensFor "X" ["a", 2]`.
|||
||| Say, you want `n` to be set by the caller to.
||| For this, you can use `%runElab generateGensFor "X" ["n"] ["a", "c"]` and
||| the signature of the main generated function becomes `{n : _} -> (a : A) -> (c : C) -> (b : B n ** X a b c)`.
|||
||| Say, you want your generator to be parameterized with some external `Gen`'s.
||| Some of these `Gen`'s are known declared `%hint x : Gen Y`, some of them should go as an `auto` parameters.
||| Consider types `data Y where ...`, `data Z1 where ...` and `data Z2 (b : B n) where ...`.
||| If you want to use `%hint` for `Gen Y` and `Gen`'s for `Z1` and `Z2` to be `auto` parameters, you can use
||| `%runElab generateGensFor "X" ["n"] ["a", "c"] {externalImplicitGens=["Z1", "Z2"]} {externalHintedGens=["Y"]}`
||| to have a function with a signature
||| `Gen Z1 => ({n : _} -> {b : B n} -> Gen (Z2 b)) => {n : _} -> (a : A) -> (c : C) -> (b : B n ** X a b c)`.
||| `%hint _ : Gen Y` from the current scope will be used as soon as a value of type `Y` will be needed for generation.
export
generateGensFor : Name ->
                  (givenImplicitParams : List DatatypeArgPointer) ->
                  (givenExplicitParams : List DatatypeArgPointer) ->
                  {default [] externalImplicitGens : List Name} ->
                  {default [] externalHintedGens : List Name} ->
                  Elab ()
generateGensFor n defImpl defExpl = do
  extImplResolved <- map (, ThruImplicit) <$> for externalImplicitGens getInfo'
  extHintResolved <- map (, ThruHint)     <$> for externalHintedGens   getInfo'
  let extResolved = extImplResolved ++ extHintResolved
  generateGensFor !(getInfo' n) !(signatureDef defImpl defExpl) extResolved
